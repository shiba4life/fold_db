# Product Backlog

This document contains all Product Backlog Items (PBIs) for the project, ordered by priority.

## Backlog

| ID | Actor | User Story | Status | Conditions of Satisfaction (CoS) |
|----|-------|------------|--------|----------------------------------|
| 2 | Developer | As a developer, I want a HashAtomRef type with complete database operations, so that I can efficiently store and retrieve key-value data with O(1) access | Proposed | 1. AtomRefHash struct implemented with HashMap-based storage<br>2. Complete database operations for hash ARefs (insert, get, remove, update, delete)<br>3. O(1) key lookup performance verified<br>4. Integration with existing AtomRef infrastructure<br>5. Comprehensive unit tests for all hash operations<br>6. Error handling for hash-specific operations [View Details](./2/prd.md) |
| 3 | Developer | As a developer, I want a composable AtomRef framework implemented, so that I can create 2-layer AtomRef composition with type safety | Proposed | 1. ComposableAtomRef enum created supporting Single and Composed variants<br>2. AtomRefType enum with Range, Hash, Collection discriminators<br>3. AtomRefFactory implemented for creating composable ARefs<br>4. Factory validates 2-layer composition limit and rejects invalid combinations<br>5. All new types have comprehensive unit tests<br>6. Composition validation logic prevents invalid combinations [View Details](./3/prd.md) |
| 4 | Developer | As a developer, I want the field type system extended to support all composable AtomRef combinations, so that schemas can define complex hierarchical data structures | Proposed | 1. FieldType enum extended with Hash, RangeCollection, RangeHash, HashCollection, HashRange, CollectionRange, CollectionHash variants<br>2. FieldType::composition() method returns constituent AtomRef types for any field type<br>3. Field serialization/deserialization handles all composable types<br>4. Validation logic prevents invalid type combinations<br>5. All field variants support composable AtomRef assignment<br>6. Backward compatibility maintained for existing Single, Collection, Range types [View Details](./4/prd.md) |
| 5 | Developer | As a developer, I want schema definitions to be pure (without aref_uuid references) and ARefs created during schema approval, so that schemas are declarative and ARefs are managed by the system | Proposed | 1. ref_atom_uuid field removed from JsonSchemaField struct<br>2. Schema approval process creates all required ARefs using AtomRefFactory<br>3. ARef-to-field mapping established during approval<br>4. Database operations updated to handle composable ARef storage/retrieval<br>5. Migration path provided for existing schemas with ref_atom_uuid references<br>6. Schema validation ensures composable types are correctly configured [View Details](./5/prd.md) |
| 6 | Developer | As a developer, I want runtime systems updated to use pre-created composable ARefs, so that field operations work seamlessly with the new composable type system | Proposed | 1. Field processing logic updated to use pre-created ARefs instead of runtime creation<br>2. Request handlers support all composable ARef type operations<br>3. Message bus events and constructors handle composable ARef operations<br>4. HTTP API endpoints support composable field types<br>5. Error handling gracefully manages missing or invalid ARefs<br>6. All existing single-layer operations continue to work without changes [View Details](./6/prd.md) |
| 7 | Developer | As a developer, I want comprehensive testing and migration support for composable AtomRefs, so that the system is reliable and existing data is safely migrated | Proposed | 1. Integration tests cover all 6 composable type combinations (RangeCollection, RangeHash, HashCollection, HashRange, CollectionRange, CollectionHash)<br>2. Performance benchmarks show <10% degradation for simple operations and <20% memory increase<br>3. Migration scripts convert existing schemas to composable system<br>4. Backward compatibility validated for all existing schemas and operations<br>5. Error scenarios and recovery procedures tested and documented<br>6. End-to-end workflows validated from schema creation through data operations [View Details](./7/prd.md) |
| 1 | Developer | As a developer, I want collection atom refs to be automatically created when schemas with collection field types become approved, so that collection fields can properly store and reference data | Done | 1. When a schema containing collection field types is approved, collection atom refs are automatically created for each collection field<br>2. The created collection atom refs are properly stored in the database<br>3. The schema fields are updated with the correct ref_atom_uuid<br>4. The system handles both new schemas and existing schemas being approved<br>5. Error handling is in place for atom ref creation failures |

## History

| Timestamp | PBI_ID | Event Type | Details | User |
|-----------|--------|------------|---------|------|
| 20241219-140000 | 2 | create_pbi | Created PBI for HashAtomRef type with complete database operations | User |
| 20241219-140100 | 3 | create_pbi | Created PBI for composable AtomRef framework implementation | User |
| 20241219-140200 | 4 | create_pbi | Created PBI for extending field type system to support composable AtomRef combinations | User |
| 20241219-140300 | 5 | create_pbi | Created PBI for schema purification and schema approval ARef creation | User |
| 20241219-140400 | 6 | create_pbi | Created PBI for runtime system updates to use composable ARefs | User |
| 20241219-140500 | 7 | create_pbi | Created PBI for comprehensive testing and migration support for composable AtomRefs | User |
| 20250119-120000 | 1 | create_pbi | Created PBI for collection atom ref creation on schema approval | User |
| 20250119-120100 | 1 | propose_for_backlog | PBI approved and moved to Agreed status | User |
| 20250119-121000 | 1 | start_implementation | Created tasks and started implementation | User |
| 20250119-130000 | 1 | approve | PBI completed successfully - collection atom refs are now created for collection fields upon schema approval | User |