# Task 9-1: Research and document AES-GCM cryptographic dependencies

**Status**: Done  
**Date**: December 8, 2024  
**Parent PBI**: [PBI 9: Encryption at Rest](./prd.md)

## Overview

This task researched and documented the cryptographic dependencies required for implementing AES-256-GCM encryption at rest in DataFold. The implementation builds on the existing crypto infrastructure from PBI 8, extending it with symmetric encryption capabilities for data at rest.

## Dependencies Added

### 1. aes-gcm v0.10

**Purpose**: Provides AES-256-GCM authenticated encryption for data at rest.

**Key Features**:
- AES-256-GCM authenticated encryption with associated data (AEAD)
- Built-in authentication to prevent tampering
- Constant-time implementation resistant to timing attacks
- Support for 96-bit nonces (recommended) and variable-length nonces
- Zero-copy API for efficient memory usage

**API Overview**:
```rust
use aes_gcm::{Aes256Gcm, Key, Nonce, KeyInit};
use aes_gcm::aead::{Aead, OsRng};

// Create cipher instance
let key = Aes256Gcm::generate_key(&mut OsRng);
let cipher = Aes256Gcm::new(&key);

// Encrypt data
let nonce = Aes256Gcm::generate_nonce(&mut OsRng);
let ciphertext = cipher.encrypt(&nonce, plaintext.as_ref())?;

// Decrypt data
let plaintext = cipher.decrypt(&nonce, ciphertext.as_ref())?;
```

**Security Properties**:
- 256-bit key strength
- 128-bit authentication tag
- Misuse-resistant when nonces are properly managed
- Constant-time operations

### 2. blake3 v1.5

**Purpose**: Fast, secure key derivation for generating encryption keys from master keys.

**Key Features**:
- Cryptographically secure hash function
- Faster than SHA-2 and SHA-3
- Built-in key derivation function (KDF) mode
- Parallelizable for performance
- 256-bit output by default (configurable)

**API Overview**:
```rust
use blake3;

// Standard hashing
let hash = blake3::hash(b"input data");

// Key derivation
let context = "DataFold Database Encryption 2024";
let derived_key = blake3::derive_key(context, &master_key);

// Keyed hashing (MAC)
let key = [0u8; 32]; // 256-bit key
let mac = blake3::keyed_hash(&key, b"message");
```

**Advantages over alternatives**:
- **vs SHA-256**: ~3x faster, modern design
- **vs PBKDF2**: No iteration count needed, more secure
- **vs scrypt**: Simpler, faster for key derivation use cases

### 3. rand v0.8 (Already Present)

**Purpose**: Cryptographically secure random number generation for nonces and keys.

**Current Usage**: Already integrated into the existing crypto infrastructure for:
- Ed25519 key generation
- Salt generation for Argon2
- General cryptographic randomness

**Additional Usage for Encryption at Rest**:
- AES-GCM nonce generation
- Additional entropy for key derivation
- Random padding where needed

## Integration with Existing Crypto Infrastructure

### Building on PBI 8 Foundation

The AES-GCM encryption system integrates with the existing master key infrastructure:

1. **Master Key Management**: Uses existing Ed25519 master keys from PBI 8
2. **Key Derivation**: Combines Argon2 (for passphrase-based keys) with BLAKE3 (for fast derivation)
3. **Configuration**: Extends existing [`CryptoConfig`](../../src/config/crypto.rs) structure
4. **Error Handling**: Uses existing [`CryptoError`](../../src/crypto/error.rs) types

### Key Derivation Chain

```
User Passphrase → Argon2 → Master Key → BLAKE3 → AES-256 Key
     (PBI 8)       (PBI 8)    (PBI 8)     (New)    (New)
```

Or for random keys:
```
Secure Random → Master Key → BLAKE3 → AES-256 Key
   (PBI 8)       (PBI 8)     (New)    (New)
```

## Security Analysis

### Cryptographic Strength

1. **AES-256-GCM**: 
   - 256-bit key = 2^256 security level
   - Authenticated encryption prevents tampering
   - Industry standard (NIST approved)

2. **BLAKE3**:
   - 256-bit output provides 128-bit security against collision attacks
   - Based on ChaCha20 permutation (well-studied)
   - Resistant to length extension attacks

3. **Combined Security**:
   - Master key security from Ed25519 (128-bit equivalent)
   - Encryption key security from AES-256 (256-bit)
   - Overall system security: min(128, 256) = 128-bit effective security

### Threat Model Coverage

| Threat | Mitigation |
|--------|------------|
| Data theft from storage | AES-256-GCM encryption |
| Data tampering | GCM authentication tag |
| Key compromise | Master key rotation capability |
| Side-channel attacks | Constant-time implementations |
| Brute force attacks | 256-bit key space |

## Performance Considerations

### Benchmarks (Approximate)

- **AES-GCM encryption**: ~1-2 GB/s on modern CPUs
- **BLAKE3 key derivation**: ~2-3 GB/s (much faster than Argon2)
- **Combined overhead**: Target <20% as specified in PBI requirements

### Optimization Strategies

1. **Async Operations**: Both aes-gcm and blake3 support async/await
2. **Batching**: Encrypt multiple atoms together when possible
3. **Key Caching**: Derive encryption keys once per session
4. **Hardware Acceleration**: AES-NI support on x86 processors

## Implementation Strategy

### Phase 1: Core Utilities (Task 9-2)
- Implement AES-256-GCM encryption/decryption functions
- Create secure nonce generation
- Add key derivation using BLAKE3

### Phase 2: Integration (Tasks 9-3 to 9-5)
- Integrate with existing key management
- Create database encryption wrapper
- Modify FoldDB for transparent encryption

### Phase 3: Production Features (Tasks 9-6 to 9-9)
- Backward compatibility
- Backup/restore
- Performance optimization
- Error handling and logging

## Alternative Dependencies Considered

### For Symmetric Encryption

1. **ChaCha20-Poly1305**: 
   - Pros: Faster on some platforms, modern design
   - Cons: Less hardware acceleration, newer standard
   - **Decision**: AES-GCM chosen for broader hardware support

2. **AES-CBC + HMAC**:
   - Pros: Well-established, separates encryption and authentication
   - Cons: More complex, potential for implementation errors
   - **Decision**: AES-GCM chosen for simplicity and built-in authentication

### For Key Derivation

1. **HKDF (RFC 5869)**:
   - Pros: IETF standard, well-studied
   - Cons: Based on SHA-256 (slower than BLAKE3)
   - **Decision**: BLAKE3 chosen for performance

2. **PBKDF2**:
   - Pros: Widely supported, NIST standard
   - Cons: Much slower, requires iteration counts
   - **Decision**: BLAKE3 chosen for speed (PBKDF2 retained for master key derivation via Argon2)

## Compatibility and Compliance

### Standards Compliance
- **FIPS 140-2**: AES-256 is FIPS approved
- **NIST Guidelines**: Follows NIST SP 800-38D for GCM mode
- **Industry Standards**: AES-GCM widely used in TLS, IPSec, etc.

### Rust Ecosystem Integration
- All crates follow Rust security best practices
- No unsafe code in cryptographic operations
- Zeroization support for sensitive data cleanup
- Integration with existing serde serialization

## Next Steps

1. **Task 9-2**: Implement core AES-256-GCM utilities using these dependencies
2. **Task 9-3**: Implement BLAKE3-based key derivation system
3. **Integration Testing**: Verify compatibility with existing PBI 8 infrastructure
4. **Performance Testing**: Benchmark encryption overhead on target workloads

## References

- [AES-GCM crate documentation](https://docs.rs/aes-gcm/latest/aes_gcm/)
- [BLAKE3 specification](https://github.com/BLAKE3-team/BLAKE3-specs)
- [NIST SP 800-38D - GCM Mode](https://csrc.nist.gov/publications/detail/sp/800-38d/final)
- [RFC 7539 - ChaCha20 and Poly1305](https://tools.ietf.org/rfc/rfc7539.txt) (for comparison)