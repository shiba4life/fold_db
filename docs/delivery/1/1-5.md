# [1-5] Add integration test for collection field schema approval

[Back to task list](./tasks.md)

## Description

Create an end-to-end integration test that verifies the complete workflow of approving schemas with collection fields. This test should use the actual HTTP API or TCP interface to create a schema with collection fields, approve it, and verify that collection atom refs are properly created.

## Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2025-01-19 12:09:00 | Created | N/A | Proposed | Task file created | User |

## Requirements

1. Create a complete integration test that tests the full workflow
2. Use actual API endpoints to create and approve schemas
3. Verify database state after approval
4. Test with realistic schema examples
5. Include error scenarios and edge cases

## Implementation Plan

1. **Create integration test file** `tests/integration/collection_field_approval_test.rs`

2. **Test schema creation and approval via HTTP API**:
   ```rust
   #[tokio::test]
   async fn test_collection_field_schema_approval_http() {
       // Start test server
       let test_env = setup_test_environment().await;
       
       // Create schema with collection fields
       let schema_json = json!({
           "name": "BlogPost",
           "fields": {
               "title": {
                   "field_type": "Single",
                   "permission_policy": {
                       "read_policy": {"NoRequirement": null},
                       "write_policy": {"Distance": 0}
                   }
               },
               "tags": {
                   "field_type": "Collection",
                   "permission_policy": {
                       "read_policy": {"NoRequirement": null},
                       "write_policy": {"Distance": 0}
                   }
               },
               "comments": {
                   "field_type": "Collection",
                   "permission_policy": {
                       "read_policy": {"NoRequirement": null},
                       "write_policy": {"Distance": 1}
                   }
               }
           }
       });
       
       // POST schema
       let response = test_env.client
           .post("/api/schema")
           .json(&schema_json)
           .send()
           .await
           .unwrap();
       assert_eq!(response.status(), 200);
       
       // Approve schema
       let response = test_env.client
           .post("/api/schema/BlogPost/approve")
           .send()
           .await
           .unwrap();
       assert_eq!(response.status(), 200);
       
       // Verify schema state
       let response = test_env.client
           .get("/api/schema/BlogPost")
           .send()
           .await
           .unwrap();
       let schema: Value = response.json().await.unwrap();
       
       // Verify collection fields have atom refs
       assert!(schema["fields"]["tags"]["ref_atom_uuid"].is_string());
       assert!(schema["fields"]["comments"]["ref_atom_uuid"].is_string());
       
       // Verify AtomRefCollections in database
       let tags_ref_uuid = schema["fields"]["tags"]["ref_atom_uuid"].as_str().unwrap();
       let stored_ref = test_env.db_ops
           .get_item::<AtomRefCollection>(&format!("ref:{}", tags_ref_uuid))
           .unwrap();
       assert!(stored_ref.is_some());
   }
   ```

3. **Test schema approval via TCP interface**:
   ```rust
   #[tokio::test]
   async fn test_collection_field_schema_approval_tcp() {
       // Similar test using TCP commands
   }
   ```

4. **Test error scenarios**:
   ```rust
   #[tokio::test]
   async fn test_collection_field_approval_error_handling() {
       // Test approval failures
       // Test invalid schema definitions
       // Test database errors
   }
   ```

5. **Test data mutations on collection fields**:
   ```rust
   #[tokio::test]
   async fn test_collection_field_mutations_after_approval() {
       // Approve schema with collection fields
       // Perform mutations to add data to collections
       // Verify data is stored correctly
   }
   ```

## Test Plan

1. **Integration Test Scenarios**:
   - Schema creation with collection fields via HTTP API
   - Schema creation with collection fields via TCP
   - Schema approval and atom ref verification
   - Mixed field type schemas
   - Error handling and recovery
   - Data mutations on approved collection fields

2. **Performance Tests**:
   - Approval of schemas with many collection fields
   - Concurrent schema approvals

3. **Backward Compatibility**:
   - Existing schemas continue to work
   - Migration of pre-existing schemas

## Verification

- [ ] HTTP API integration test passes
- [ ] TCP interface integration test passes
- [ ] Collection atom refs are created and persisted
- [ ] Error scenarios are handled gracefully
- [ ] Performance is acceptable
- [ ] No regression in existing functionality

## Files Modified

- `tests/integration/collection_field_approval_test.rs` (new file)
- `tests/integration/mod.rs` (if needed to include new test module)