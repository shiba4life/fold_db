# [1-2] Update map_fields to handle collection fields

[Back to task list](./tasks.md)

## Description

Modify the map_fields function in `src/schema/core.rs` to create AtomRefCollection instances for collection fields during schema approval. Currently, the function only handles Single and Range fields, with a TODO comment for collection fields.

## Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2025-01-19 12:06:00 | Created | N/A | Proposed | Task file created | User |
| 2025-01-19 12:26:00 | user_approves | Proposed | Agreed | Task approved for implementation | User |
| 2025-01-19 12:27:00 | start_work | Agreed | InProgress | Started implementation | AI_Agent |
| 2025-01-19 12:35:00 | submit_for_review | InProgress | Review | Implementation complete, ready for review | AI_Agent |

## Requirements

1. Update the `map_fields` function to handle `FieldVariant::Collection` 
2. Create `AtomRefCollection` instances for collection fields
3. Store the collection atom refs in the database
4. Set the `ref_atom_uuid` on collection fields
5. Ensure proper error handling and logging

## Implementation Plan

1. **Locate the TODO comment** in `map_fields` function (around line 1469)

2. **Add Collection field handling**:
   ```rust
   FieldVariant::Collection(_) => {
       // For collection fields, create AtomRefCollection
       let atom_ref_collection = AtomRefCollection::new("system".to_string());
       if let Err(e) = self.db_ops.store_item(&key, &atom_ref_collection) {
           info!("Failed to persist AtomRefCollection '{}': {}", ref_atom_uuid, e);
       } else {
           info!("âœ… Persisted AtomRefCollection: {}", key);
       }
       // Create a corresponding AtomRef for the return list
       atom_refs.push(AtomRef::new(Uuid::new_v4().to_string(), "system".to_string()));
   }
   ```

3. **Update match statement** in the field type checking section

4. **Add logging** for collection field processing

5. **Test the changes** with schemas containing collection fields

## Test Plan

1. **Unit Tests**:
   - Test map_fields with a schema containing collection fields
   - Verify AtomRefCollection is created and stored
   - Verify ref_atom_uuid is set on the field

2. **Integration Tests**:
   - Create a schema with collection fields
   - Approve the schema
   - Verify collection atom refs are created in the database

3. **Manual Testing**:
   - Use the API to create and approve a schema with collection fields
   - Check database for stored AtomRefCollection instances

## Verification

- [x] map_fields function handles FieldVariant::Collection
- [x] AtomRefCollection instances are created for collection fields
- [x] Collection atom refs are stored in database with correct key format
- [x] ref_atom_uuid is set on collection fields
- [x] Appropriate logging is in place
- [ ] Unit tests pass
- [ ] Integration tests pass

## Files Modified

- `src/schema/core.rs` (added AtomRefCollection import and Collection variant handling in map_fields)