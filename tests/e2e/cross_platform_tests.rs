//! Cross-Platform Integration Tests
//!
//! This module tests interoperability between different client implementations
//! (JavaScript SDK, Python SDK, CLI tool) and the DataFold server, ensuring
//! signatures generated by one platform can be verified by others.

use super::test_utils::{E2ETestConfig, TestCredentials, E2EHttpClient, E2ETestResults, utils};
use super::server_harness::TestServerHarness;
use super::sdk_harness::{JavaScriptSDKHarness, PythonSDKHarness, CLIHarness};
use datafold::datafold_node::signature_auth::SecurityProfile;
use serde_json::{json, Value};
use std::collections::HashMap;
use std::time::Duration;
use tokio::time::timeout;

/// Cross-platform integration test suite
pub struct CrossPlatformTests {
    config: E2ETestConfig,
    results: E2ETestResults,
}

impl CrossPlatformTests {
    /// Create new cross-platform test suite
    pub fn new(config: E2ETestConfig) -> Self {
        Self {
            config,
            results: E2ETestResults::default(),
        }
    }

    /// Run all cross-platform tests
    pub async fn run_all_tests(&mut self) -> anyhow::Result<E2ETestResults> {
        log::info!("üåê Starting Cross-Platform Integration Tests");

        // Test 1: JavaScript SDK with DataFold server
        self.test_javascript_sdk_integration().await?;

        // Test 2: Python SDK with DataFold server
        self.test_python_sdk_integration().await?;

        // Test 3: CLI tool with DataFold server
        self.test_cli_integration().await?;

        // Test 4: Cross-platform signature verification
        self.test_cross_platform_signature_verification().await?;

        // Test 5: Mixed client scenario testing
        self.test_mixed_client_scenarios().await?;

        // Test 6: Message canonicalization consistency
        self.test_message_canonicalization_consistency().await?;

        // Test 7: Configuration compatibility
        self.test_configuration_compatibility().await?;

        log::info!("‚úÖ Cross-Platform Tests Complete: {}/{} passed", 
                  self.results.passed_tests, self.results.total_tests);

        Ok(self.results.clone())
    }

    /// Test JavaScript SDK integration with DataFold server
    async fn test_javascript_sdk_integration(&mut self) -> anyhow::Result<()> {
        log::info!("üß™ Testing JavaScript SDK integration");

        let test_result = timeout(Duration::from_secs(self.config.test_timeout_secs), async {
            // Step 1: Start test server
            let mut server_harness = TestServerHarness::new(SecurityProfile::Standard).await?;
            server_harness.start().await?;

            // Step 2: Initialize JavaScript SDK harness
            let mut js_harness = JavaScriptSDKHarness::new(&self.config).await?;
            js_harness.setup().await?;

            // Step 3: Generate test credentials
            let credentials = TestCredentials::generate()?;

            // Step 4: Register public key via server
            let mut server_client = E2EHttpClient::new(server_harness.base_url().to_string());
            server_client.wait_for_server(20).await?;
            
            let registration_id = server_client.register_public_key(&credentials).await?;
            log::info!("‚úì Public key registered: {}", registration_id);

            // Step 5: Generate signature using JavaScript SDK
            let test_request = json!({
                "method": "POST",
                "uri": "/api/test/js-integration",
                "headers": {
                    "content-type": "application/json",
                    "x-client-platform": "javascript"
                },
                "body": {
                    "test_data": "javascript_sdk_integration",
                    "timestamp": utils::current_timestamp()
                }
            });

            let (signature_time, signature_components) = utils::measure_time(|| async {
                js_harness.sign_request(&credentials, &test_request).await
            }).await;

            let signature_components = signature_components?;
            self.results.add_metric("js_signature_generation_ms", signature_time.as_millis() as f64);

            log::info!("‚úì JavaScript signature generated ({}ms)", signature_time.as_millis());

            // Step 6: Verify signature with DataFold server
            let (verification_time, verification_result) = utils::measure_time(|| async {
                js_harness.verify_with_server(server_harness.base_url(), &signature_components).await
            }).await;

            let verification_result = verification_result?;
            self.results.add_metric("js_server_verification_ms", verification_time.as_millis() as f64);

            if !verification_result {
                return Err(anyhow::anyhow!("JavaScript SDK signature verification failed"));
            }

            log::info!("‚úì JavaScript signature verified by server ({}ms)", verification_time.as_millis());

            // Step 7: Test API request flow
            let api_response = js_harness.make_authenticated_request(
                server_harness.base_url(),
                &credentials,
                "POST",
                "/api/test/js-authenticated",
                Some(json!({
                    "platform": "javascript",
                    "test_type": "integration"
                })),
            ).await?;

            if !api_response.status().is_success() {
                return Err(anyhow::anyhow!("JavaScript SDK authenticated request failed"));
            }

            log::info!("‚úì JavaScript SDK authenticated API request successful");

            // Step 8: Cleanup
            js_harness.cleanup().await?;
            server_harness.stop().await?;

            Ok::<(), anyhow::Error>(())
        }).await;

        match test_result {
            Ok(Ok(())) => {
                self.results.add_result("javascript_sdk_integration", true, None);
                log::info!("‚úÖ JavaScript SDK integration test passed");
            }
            Ok(Err(e)) => {
                self.results.add_result("javascript_sdk_integration", false, Some(e.to_string()));
                log::error!("‚ùå JavaScript SDK integration test failed: {}", e);
            }
            Err(_) => {
                self.results.add_result("javascript_sdk_integration", false, Some("Test timeout".to_string()));
                log::error!("‚ùå JavaScript SDK integration test timed out");
            }
        }

        Ok(())
    }

    /// Test Python SDK integration with DataFold server
    async fn test_python_sdk_integration(&mut self) -> anyhow::Result<()> {
        log::info!("üß™ Testing Python SDK integration");

        let test_result = timeout(Duration::from_secs(self.config.test_timeout_secs), async {
            // Step 1: Start test server
            let mut server_harness = TestServerHarness::new(SecurityProfile::Standard).await?;
            server_harness.start().await?;

            // Step 2: Initialize Python SDK harness
            let mut python_harness = PythonSDKHarness::new(&self.config).await?;
            python_harness.setup().await?;

            // Step 3: Generate test credentials
            let credentials = TestCredentials::generate()?;

            // Step 4: Register public key via server
            let mut server_client = E2EHttpClient::new(server_harness.base_url().to_string());
            server_client.wait_for_server(20).await?;
            
            let registration_id = server_client.register_public_key(&credentials).await?;
            log::info!("‚úì Public key registered: {}", registration_id);

            // Step 5: Generate signature using Python SDK
            let test_request = json!({
                "method": "POST",
                "uri": "/api/test/python-integration",
                "headers": {
                    "content-type": "application/json",
                    "x-client-platform": "python"
                },
                "body": {
                    "test_data": "python_sdk_integration",
                    "timestamp": utils::current_timestamp()
                }
            });

            let (signature_time, signature_components) = utils::measure_time(|| async {
                python_harness.sign_request(&credentials, &test_request).await
            }).await;

            let signature_components = signature_components?;
            self.results.add_metric("python_signature_generation_ms", signature_time.as_millis() as f64);

            log::info!("‚úì Python signature generated ({}ms)", signature_time.as_millis());

            // Step 6: Verify signature with DataFold server
            let (verification_time, verification_result) = utils::measure_time(|| async {
                python_harness.verify_with_server(server_harness.base_url(), &signature_components).await
            }).await;

            let verification_result = verification_result?;
            self.results.add_metric("python_server_verification_ms", verification_time.as_millis() as f64);

            if !verification_result {
                return Err(anyhow::anyhow!("Python SDK signature verification failed"));
            }

            log::info!("‚úì Python signature verified by server ({}ms)", verification_time.as_millis());

            // Step 7: Test API request flow
            let api_response = python_harness.make_authenticated_request(
                server_harness.base_url(),
                &credentials,
                "POST",
                "/api/test/python-authenticated",
                Some(json!({
                    "platform": "python",
                    "test_type": "integration"
                })),
            ).await?;

            if !api_response.status().is_success() {
                return Err(anyhow::anyhow!("Python SDK authenticated request failed"));
            }

            log::info!("‚úì Python SDK authenticated API request successful");

            // Step 8: Cleanup
            python_harness.cleanup().await?;
            server_harness.stop().await?;

            Ok::<(), anyhow::Error>(())
        }).await;

        match test_result {
            Ok(Ok(())) => {
                self.results.add_result("python_sdk_integration", true, None);
                log::info!("‚úÖ Python SDK integration test passed");
            }
            Ok(Err(e)) => {
                self.results.add_result("python_sdk_integration", false, Some(e.to_string()));
                log::error!("‚ùå Python SDK integration test failed: {}", e);
            }
            Err(_) => {
                self.results.add_result("python_sdk_integration", false, Some("Test timeout".to_string()));
                log::error!("‚ùå Python SDK integration test timed out");
            }
        }

        Ok(())
    }

    /// Test CLI tool integration with DataFold server
    async fn test_cli_integration(&mut self) -> anyhow::Result<()> {
        log::info!("üß™ Testing CLI tool integration");

        let test_result = timeout(Duration::from_secs(self.config.test_timeout_secs), async {
            // Step 1: Start test server
            let mut server_harness = TestServerHarness::new(SecurityProfile::Standard).await?;
            server_harness.start().await?;

            // Step 2: Initialize CLI harness
            let mut cli_harness = CLIHarness::new(&self.config).await?;
            cli_harness.setup().await?;

            // Step 3: Generate test credentials using CLI
            let (key_gen_time, credentials) = utils::measure_time(|| async {
                cli_harness.generate_credentials().await
            }).await;

            let credentials = credentials?;
            self.results.add_metric("cli_key_generation_ms", key_gen_time.as_millis() as f64);

            log::info!("‚úì CLI credentials generated ({}ms)", key_gen_time.as_millis());

            // Step 4: Register public key using CLI
            let (registration_time, registration_id) = utils::measure_time(|| async {
                cli_harness.register_key_with_server(server_harness.base_url(), &credentials).await
            }).await;

            let registration_id = registration_id?;
            self.results.add_metric("cli_key_registration_ms", registration_time.as_millis() as f64);

            log::info!("‚úì CLI key registered: {} ({}ms)", registration_id, registration_time.as_millis());

            // Step 5: Test CLI authentication flow
            let (auth_time, auth_result) = utils::measure_time(|| async {
                cli_harness.test_authentication(server_harness.base_url(), &credentials).await
            }).await;

            let auth_result = auth_result?;
            self.results.add_metric("cli_authentication_ms", auth_time.as_millis() as f64);

            if !auth_result {
                return Err(anyhow::anyhow!("CLI authentication test failed"));
            }

            log::info!("‚úì CLI authentication successful ({}ms)", auth_time.as_millis());

            // Step 6: Test CLI signing and verification
            let message = "CLI integration test message";
            let (signing_time, signature) = utils::measure_time(|| async {
                cli_harness.sign_message(&credentials, message).await
            }).await;

            let signature = signature?;
            self.results.add_metric("cli_message_signing_ms", signing_time.as_millis() as f64);

            let (verification_time, is_valid) = utils::measure_time(|| async {
                cli_harness.verify_signature(&credentials, message, &signature).await
            }).await;

            let is_valid = is_valid?;
            self.results.add_metric("cli_signature_verification_ms", verification_time.as_millis() as f64);

            if !is_valid {
                return Err(anyhow::anyhow!("CLI signature verification failed"));
            }

            log::info!("‚úì CLI signature generation and verification successful");

            // Step 7: Cleanup
            cli_harness.cleanup().await?;
            server_harness.stop().await?;

            Ok::<(), anyhow::Error>(())
        }).await;

        match test_result {
            Ok(Ok(())) => {
                self.results.add_result("cli_integration", true, None);
                log::info!("‚úÖ CLI integration test passed");
            }
            Ok(Err(e)) => {
                self.results.add_result("cli_integration", false, Some(e.to_string()));
                log::error!("‚ùå CLI integration test failed: {}", e);
            }
            Err(_) => {
                self.results.add_result("cli_integration", false, Some("Test timeout".to_string()));
                log::error!("‚ùå CLI integration test timed out");
            }
        }

        Ok(())
    }

    /// Test cross-platform signature verification
    async fn test_cross_platform_signature_verification(&mut self) -> anyhow::Result<()> {
        log::info!("üß™ Testing cross-platform signature verification");

        let test_result = timeout(Duration::from_secs(self.config.test_timeout_secs * 2), async {
            // Step 1: Start test server
            let mut server_harness = TestServerHarness::new(SecurityProfile::Standard).await?;
            server_harness.start().await?;

            // Step 2: Initialize all SDK harnesses
            let mut js_harness = JavaScriptSDKHarness::new(&self.config).await?;
            js_harness.setup().await?;

            let mut python_harness = PythonSDKHarness::new(&self.config).await?;
            python_harness.setup().await?;

            let mut cli_harness = CLIHarness::new(&self.config).await?;
            cli_harness.setup().await?;

            // Step 3: Generate shared test credentials
            let credentials = TestCredentials::generate()?;

            // Register key with server
            let mut server_client = E2EHttpClient::new(server_harness.base_url().to_string());
            server_client.wait_for_server(20).await?;
            let registration_id = server_client.register_public_key(&credentials).await?;

            log::info!("‚úì Shared credentials registered: {}", registration_id);

            // Step 4: Create test message for signing
            let test_message = json!({
                "method": "POST",
                "uri": "/api/test/cross-platform",
                "headers": {
                    "content-type": "application/json"
                },
                "body": {
                    "test_data": "cross_platform_verification",
                    "timestamp": utils::current_timestamp()
                }
            });

            // Step 5: Test JavaScript -> Python verification
            let js_signature = js_harness.sign_request(&credentials, &test_message).await?;
            let js_to_python_result = python_harness.verify_signature(&credentials, &test_message, &js_signature).await?;
            
            if !js_to_python_result {
                return Err(anyhow::anyhow!("JavaScript -> Python verification failed"));
            }
            log::info!("‚úì JavaScript -> Python verification successful");

            // Step 6: Test Python -> JavaScript verification
            let python_signature = python_harness.sign_request(&credentials, &test_message).await?;
            let python_to_js_result = js_harness.verify_signature(&credentials, &test_message, &python_signature).await?;
            
            if !python_to_js_result {
                return Err(anyhow::anyhow!("Python -> JavaScript verification failed"));
            }
            log::info!("‚úì Python -> JavaScript verification successful");

            // Step 7: Test CLI -> SDKs verification
            let message_str = serde_json::to_string(&test_message)?;
            let cli_signature = cli_harness.sign_message(&credentials, &message_str).await?;
            
            let cli_to_js_result = js_harness.verify_raw_signature(&credentials, &message_str, &cli_signature).await?;
            let cli_to_python_result = python_harness.verify_raw_signature(&credentials, &message_str, &cli_signature).await?;

            if !cli_to_js_result {
                return Err(anyhow::anyhow!("CLI -> JavaScript verification failed"));
            }
            if !cli_to_python_result {
                return Err(anyhow::anyhow!("CLI -> Python verification failed"));
            }
            log::info!("‚úì CLI -> SDKs verification successful");

            // Step 8: Test server verification of all platforms
            let server_js_result = js_harness.verify_with_server(server_harness.base_url(), &js_signature).await?;
            let server_python_result = python_harness.verify_with_server(server_harness.base_url(), &python_signature).await?;

            if !server_js_result || !server_python_result {
                return Err(anyhow::anyhow!("Server verification of SDK signatures failed"));
            }
            log::info!("‚úì Server verification of all platforms successful");

            // Step 9: Cleanup
            js_harness.cleanup().await?;
            python_harness.cleanup().await?;
            cli_harness.cleanup().await?;
            server_harness.stop().await?;

            Ok::<(), anyhow::Error>(())
        }).await;

        match test_result {
            Ok(Ok(())) => {
                self.results.add_result("cross_platform_verification", true, None);
                log::info!("‚úÖ Cross-platform signature verification test passed");
            }
            Ok(Err(e)) => {
                self.results.add_result("cross_platform_verification", false, Some(e.to_string()));
                log::error!("‚ùå Cross-platform signature verification test failed: {}", e);
            }
            Err(_) => {
                self.results.add_result("cross_platform_verification", false, Some("Test timeout".to_string()));
                log::error!("‚ùå Cross-platform signature verification test timed out");
            }
        }

        Ok(())
    }

    /// Test mixed client scenarios
    async fn test_mixed_client_scenarios(&mut self) -> anyhow::Result<()> {
        log::info!("üß™ Testing mixed client scenarios");

        let test_result = timeout(Duration::from_secs(self.config.test_timeout_secs * 2), async {
            // Step 1: Start test server
            let mut server_harness = TestServerHarness::new(SecurityProfile::Standard).await?;
            server_harness.start().await?;

            // Step 2: Create multiple clients of different types
            let mut js_harness = JavaScriptSDKHarness::new(&self.config).await?;
            js_harness.setup().await?;

            let mut python_harness = PythonSDKHarness::new(&self.config).await?;
            python_harness.setup().await?;

            // Step 3: Generate credentials for each client type
            let js_credentials = TestCredentials::generate()?;
            let python_credentials = TestCredentials::generate()?;

            // Register all keys
            let mut server_client = E2EHttpClient::new(server_harness.base_url().to_string());
            server_client.wait_for_server(20).await?;

            let js_registration = server_client.register_public_key(&js_credentials).await?;
            let python_registration = server_client.register_public_key(&python_credentials).await?;

            log::info!("‚úì Mixed client credentials registered");

            // Step 4: Concurrent requests from different platforms
            let js_handle = {
                let js_harness = js_harness.clone(); // This would need to be implemented
                let js_credentials = js_credentials.clone();
                let server_url = server_harness.base_url().to_string();
                
                tokio::spawn(async move {
                    for i in 0..5 {
                        let result = js_harness.make_authenticated_request(
                            &server_url,
                            &js_credentials,
                            "GET",
                            &format!("/api/test/mixed/js/{}", i),
                            None,
                        ).await;
                        
                        if result.is_err() {
                            return Err(anyhow::anyhow!("JavaScript request {} failed", i));
                        }
                        
                        tokio::time::sleep(Duration::from_millis(100)).await;
                    }
                    Ok::<(), anyhow::Error>(())
                })
            };

            let python_handle = {
                let python_harness = python_harness.clone(); // This would need to be implemented
                let python_credentials = python_credentials.clone();
                let server_url = server_harness.base_url().to_string();
                
                tokio::spawn(async move {
                    for i in 0..5 {
                        let result = python_harness.make_authenticated_request(
                            &server_url,
                            &python_credentials,
                            "GET",
                            &format!("/api/test/mixed/python/{}", i),
                            None,
                        ).await;
                        
                        if result.is_err() {
                            return Err(anyhow::anyhow!("Python request {} failed", i));
                        }
                        
                        tokio::time::sleep(Duration::from_millis(150)).await;
                    }
                    Ok::<(), anyhow::Error>(())
                })
            };

            // Step 5: Wait for all concurrent requests
            let (js_result, python_result) = tokio::try_join!(js_handle, python_handle)?;
            
            js_result?;
            python_result?;

            log::info!("‚úì Concurrent mixed client requests successful");

            // Step 6: Test platform-specific features
            let js_specific_result = js_harness.test_platform_specific_features(&js_credentials).await?;
            let python_specific_result = python_harness.test_platform_specific_features(&python_credentials).await?;

            if !js_specific_result || !python_specific_result {
                return Err(anyhow::anyhow!("Platform-specific feature tests failed"));
            }

            log::info!("‚úì Platform-specific features working correctly");

            // Step 7: Cleanup
            js_harness.cleanup().await?;
            python_harness.cleanup().await?;
            server_harness.stop().await?;

            Ok::<(), anyhow::Error>(())
        }).await;

        match test_result {
            Ok(Ok(())) => {
                self.results.add_result("mixed_client_scenarios", true, None);
                log::info!("‚úÖ Mixed client scenarios test passed");
            }
            Ok(Err(e)) => {
                self.results.add_result("mixed_client_scenarios", false, Some(e.to_string()));
                log::error!("‚ùå Mixed client scenarios test failed: {}", e);
            }
            Err(_) => {
                self.results.add_result("mixed_client_scenarios", false, Some("Test timeout".to_string()));
                log::error!("‚ùå Mixed client scenarios test timed out");
            }
        }

        Ok(())
    }

    /// Test message canonicalization consistency across platforms
    async fn test_message_canonicalization_consistency(&mut self) -> anyhow::Result<()> {
        log::info!("üß™ Testing message canonicalization consistency");

        let test_result = timeout(Duration::from_secs(self.config.test_timeout_secs), async {
            // Step 1: Initialize all SDK harnesses
            let mut js_harness = JavaScriptSDKHarness::new(&self.config).await?;
            js_harness.setup().await?;

            let mut python_harness = PythonSDKHarness::new(&self.config).await?;
            python_harness.setup().await?;

            let mut cli_harness = CLIHarness::new(&self.config).await?;
            cli_harness.setup().await?;

            // Step 2: Create test request with various edge cases
            let test_requests = vec![
                json!({
                    "method": "GET",
                    "uri": "/api/test/simple",
                    "headers": {
                        "content-type": "application/json"
                    }
                }),
                json!({
                    "method": "POST",
                    "uri": "/api/test/complex?param1=value1&param2=value%20with%20spaces",
                    "headers": {
                        "content-type": "application/json",
                        "x-custom-header": "Custom Value",
                        "authorization": "Bearer token123"
                    },
                    "body": {
                        "nested": {
                            "data": ["item1", "item2"],
                            "unicode": "üîê Test Data ÊµãËØï"
                        }
                    }
                }),
                json!({
                    "method": "PUT",
                    "uri": "/api/test/edge-cases",
                    "headers": {
                        "content-type": "application/json; charset=utf-8",
                        "accept": "application/json, text/plain",
                        "x-empty-header": "",
                        "x-special-chars": "!@#$%^&*()[]{}|\\:;\"'<>?,./"
                    }
                })
            ];

            // Step 3: Test canonicalization consistency for each request
            for (i, test_request) in test_requests.iter().enumerate() {
                log::info!("Testing canonicalization consistency for request {}", i + 1);

                // Get canonical message from each platform
                let js_canonical = js_harness.canonicalize_message(test_request).await?;
                let python_canonical = python_harness.canonicalize_message(test_request).await?;
                let cli_canonical = cli_harness.canonicalize_message(test_request).await?;

                // Compare canonical messages
                if js_canonical != python_canonical {
                    return Err(anyhow::anyhow!(
                        "Canonicalization mismatch between JavaScript and Python for request {}", i + 1
                    ));
                }

                if python_canonical != cli_canonical {
                    return Err(anyhow::anyhow!(
                        "Canonicalization mismatch between Python and CLI for request {}", i + 1
                    ));
                }

                log::info!("‚úì Request {} canonicalization consistent across platforms", i + 1);
            }

            // Step 4: Test edge cases with special characters
            let edge_case_headers = json!({
                "method": "POST",
                "uri": "/api/test/unicode",
                "headers": {
                    "content-type": "application/json; charset=utf-8",
                    "x-unicode-header": "Header with ‰∏≠Êñá and √©mojis üöÄ",
                    "x-case-sensitivity": "Mixed Case Header"
                },
                "body": {
                    "unicode_content": "Testing unicode: ‰∏≠Êñá, ÿßŸÑÿπÿ±ÿ®Ÿäÿ©, ‡§π‡§ø‡§®‡•ç‡§¶‡•Ä, —Ä—É—Å—Å–∫–∏–π, Êó•Êú¨Ë™û"
                }
            });

            let js_unicode_canonical = js_harness.canonicalize_message(&edge_case_headers).await?;
            let python_unicode_canonical = python_harness.canonicalize_message(&edge_case_headers).await?;

            if js_unicode_canonical != python_unicode_canonical {
                return Err(anyhow::anyhow!("Unicode canonicalization inconsistency"));
            }

            log::info!("‚úì Unicode and special character canonicalization consistent");

            // Step 5: Cleanup
            js_harness.cleanup().await?;
            python_harness.cleanup().await?;
            cli_harness.cleanup().await?;

            Ok::<(), anyhow::Error>(())
        }).await;

        match test_result {
            Ok(Ok(())) => {
                self.results.add_result("canonicalization_consistency", true, None);
                log::info!("‚úÖ Message canonicalization consistency test passed");
            }
            Ok(Err(e)) => {
                self.results.add_result("canonicalization_consistency", false, Some(e.to_string()));
                log::error!("‚ùå Message canonicalization consistency test failed: {}", e);
            }
            Err(_) => {
                self.results.add_result("canonicalization_consistency", false, Some("Test timeout".to_string()));
                log::error!("‚ùå Message canonicalization consistency test timed out");
            }
        }

        Ok(())
    }

    /// Test configuration compatibility across platforms
    async fn test_configuration_compatibility(&mut self) -> anyhow::Result<()> {
        log::info!("üß™ Testing configuration compatibility");

        let test_result = timeout(Duration::from_secs(self.config.test_timeout_secs), async {
            // Step 1: Define test configurations
            let test_configs = vec![
                json!({
                    "security_profile": "strict",
                    "allowed_window_secs": 60,
                    "clock_skew_tolerance_secs": 5,
                    "require_uuid4_nonces": true
                }),
                json!({
                    "security_profile": "standard",
                    "allowed_window_secs": 300,
                    "clock_skew_tolerance_secs": 30,
                    "require_uuid4_nonces": true
                }),
                json!({
                    "security_profile": "lenient",
                    "allowed_window_secs": 600,
                    "clock_skew_tolerance_secs": 120,
                    "require_uuid4_nonces": false
                })
            ];

            // Step 2: Test each configuration across platforms
            for (i, config) in test_configs.iter().enumerate() {
                log::info!("Testing configuration compatibility {}", i + 1);

                // Start server with specific configuration
                let mut server_harness = TestServerHarness::new(
                    match config["security_profile"].as_str().unwrap() {
                        "strict" => SecurityProfile::Strict,
                        "standard" => SecurityProfile::Standard,
                        "lenient" => SecurityProfile::Lenient,
                        _ => SecurityProfile::Standard,
                    }
                ).await?;
                server_harness.start().await?;

                // Initialize SDKs with matching configuration
                let mut js_harness = JavaScriptSDKHarness::with_config(&self.config, config.clone()).await?;
                js_harness.setup().await?;

                let mut python_harness = PythonSDKHarness::with_config(&self.config, config.clone()).await?;
                python_harness.setup().await?;

                // Test that all platforms work with this configuration
                let credentials = TestCredentials::generate()?;
                
                let mut server_client = E2EHttpClient::new(server_harness.base_url().to_string());
                server_client.wait_for_server(20).await?;
                server_client.register_public_key(&credentials).await?;

                // Test JavaScript SDK with configuration
                let js_result = js_harness.test_configuration_compliance(&credentials).await?;
                if !js_result {
                    return Err(anyhow::anyhow!("JavaScript SDK configuration {} failed", i + 1));
                }

                // Test Python SDK with configuration
                let python_result = python_harness.test_configuration_compliance(&credentials).await?;
                if !python_result {
                    return Err(anyhow::anyhow!("Python SDK configuration {} failed", i + 1));
                }

                log::info!("‚úì Configuration {} compatible across platforms", i + 1);

                // Cleanup for next iteration
                js_harness.cleanup().await?;
                python_harness.cleanup().await?;
                server_harness.stop().await?;
            }

            Ok::<(), anyhow::Error>(())
        }).await;

        match test_result {
            Ok(Ok(())) => {
                self.results.add_result("configuration_compatibility", true, None);
                log::info!("‚úÖ Configuration compatibility test passed");
            }
            Ok(Err(e)) => {
                self.results.add_result("configuration_compatibility", false, Some(e.to_string()));
                log::error!("‚ùå Configuration compatibility test failed: {}", e);
            }
            Err(_) => {
                self.results.add_result("configuration_compatibility", false, Some("Test timeout".to_string()));
                log::error!("‚ùå Configuration compatibility test timed out");
            }
        }

        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::tests::e2e::init_e2e_environment;

    #[tokio::test]
    async fn test_cross_platform_test_suite() {
        init_e2e_environment();
        
        let config = E2ETestConfig {
            server_url: "http://localhost:8080".to_string(),
            test_timeout_secs: 30,
            concurrent_clients: 3,
            enable_attack_simulation: false,
            temp_dir: std::env::temp_dir(),
        };

        let mut cross_platform_tests = CrossPlatformTests::new(config);
        
        // For now, just test that the structure works
        assert_eq!(cross_platform_tests.results.total_tests, 0);
    }
}