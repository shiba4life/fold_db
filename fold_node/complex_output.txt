warning: methods `parse_stmt`, `parse_if_stmt`, `parse_let_stmt`, `parse_return_stmt`, `parse_expr_stmt`, and `parse_comp_op` are never used
   --> fold_node/src/schema/transform/better_parser.rs:356:8
    |
20  | impl BetterParser {
    | ----------------- methods in this implementation
...
356 |     fn parse_stmt(&self, pair: Pair<Rule>) -> Result<Expression, SchemaError> {
    |        ^^^^^^^^^^
...
369 |     fn parse_if_stmt(&self, pair: Pair<Rule>) -> Result<Expression, SchemaError> {
    |        ^^^^^^^^^^^^^
...
448 |     fn parse_let_stmt(&self, pair: Pair<Rule>) -> Result<Expression, SchemaError> {
    |        ^^^^^^^^^^^^^^
...
467 |     fn parse_return_stmt(&self, pair: Pair<Rule>) -> Result<Expression, SchemaError> {
    |        ^^^^^^^^^^^^^^^^^
...
478 |     fn parse_expr_stmt(&self, pair: Pair<Rule>) -> Result<Expression, SchemaError> {
    |        ^^^^^^^^^^^^^^^
...
676 |     fn parse_comp_op(&self, pair: Pair<Rule>) -> Result<Operator, SchemaError> {
    |        ^^^^^^^^^^^^^
    |
    = note: `#[warn(dead_code)]` on by default

warning: `fold_node` (lib) generated 1 warning
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.15s
     Running `/Users/tomtang/projects/engram/datafold/target/debug/examples/complex_transform_dsl`
Complex Transform DSL Example
============================

Parser created

Complex transform with let and return statements:

    transform calculate_bmi {
      input: Fold<PatientVitals>
      output: Field<Float> as "bmi"
      reversible: false
      signature: sha256sum("v1.0.0")
      
      logic: {
        let height_m = input.height / 100;  // Convert cm to m
        let bmi = input.weight / (height_m ^ 2);
        return bmi;
      }
    }
    
Transform parsed successfully!
Transform name: calculate_bmi
Output name: bmi
Reversible: false
Signature: sha256sum("v1.0.0")
Logic statements: 3
Statement 1: LetBinding { name: "height_m", value: BinaryOp { left: FieldAccess { object: Variable("input"), field: "height" }, operator: Divide, right: Literal(Number(100.0)) }, body: Literal(Null) }
Statement 2: LetBinding { name: "bmi", value: BinaryOp { left: FieldAccess { object: Variable("input"), field: "weight" }, operator: Divide, right: BinaryOp { left: Variable("height_m"), operator: Power, right: Literal(Number(2.0)) } }, body: Literal(Null) }
Statement 3: Return(Variable("bmi"))

Evaluating statement 1: LetBinding { name: "height_m", value: BinaryOp { left: FieldAccess { object: Variable("input"), field: "height" }, operator: Divide, right: Literal(Number(100.0)) }, body: Literal(Null) }
  Result: Number(1.75)

Evaluating statement 2: LetBinding { name: "bmi", value: BinaryOp { left: FieldAccess { object: Variable("input"), field: "weight" }, operator: Divide, right: BinaryOp { left: Variable("height_m"), operator: Power, right: Literal(Number(2.0)) } }, body: Literal(Null) }
  Result: Number(22.857142857142858)

Evaluating statement 3: Return(Variable("bmi"))
  Result: Number(22.857142857142858)

Risk score transform with complex logic:

    transform calculate_risk_score {
      input: Fold<PatientData>
      output: Field<Float> as "risk_score"
      reversible: false
      signature: sha256sum("v1.0.1")
      
      logic: {
        let base_score = 50;
        let age_factor = input.age / 10;
        let bmi_factor = (input.bmi - 25) * 2;
        let bp_factor = (input.systolic - 120) / 10;
        let risk = base_score + age_factor + bmi_factor + bp_factor;
        return clamp(risk, 0, 100);
      }
    }
    
Transform parsed successfully!
Transform name: calculate_risk_score
Output name: risk_score
Logic statements: 6

Evaluating statement 1: LetBinding { name: "base_score", value: Literal(Number(50.0)), body: Literal(Null) }
  Result: Number(50.0)

Evaluating statement 2: LetBinding { name: "age_factor", value: BinaryOp { left: FieldAccess { object: Variable("input"), field: "age" }, operator: Divide, right: Literal(Number(10.0)) }, body: Literal(Null) }
  Result: Number(4.5)

Evaluating statement 3: LetBinding { name: "bmi_factor", value: BinaryOp { left: BinaryOp { left: FieldAccess { object: Variable("input"), field: "bmi" }, operator: Subtract, right: Literal(Number(25.0)) }, operator: Multiply, right: Literal(Number(2.0)) }, body: Literal(Null) }
  Result: Number(6.0)

Evaluating statement 4: LetBinding { name: "bp_factor", value: BinaryOp { left: BinaryOp { left: FieldAccess { object: Variable("input"), field: "systolic" }, operator: Subtract, right: Literal(Number(120.0)) }, operator: Divide, right: Literal(Number(10.0)) }, body: Literal(Null) }
  Result: Number(1.0)

Evaluating statement 5: LetBinding { name: "risk", value: BinaryOp { left: BinaryOp { left: BinaryOp { left: Variable("base_score"), operator: Add, right: Variable("age_factor") }, operator: Add, right: Variable("bmi_factor") }, operator: Add, right: Variable("bp_factor") }, body: Literal(Null) }
  Result: Number(61.5)

Evaluating statement 6: Return(FunctionCall { name: "clamp", args: [Variable("risk"), Literal(Number(0.0)), Literal(Number(100.0))] })
  Result: Number(61.5)
